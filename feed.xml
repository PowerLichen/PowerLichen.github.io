<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://powerlichen.github.io/</id><title>PowerLichen.blog</title><subtitle>Django 개발 정리 블로그.</subtitle> <updated>2024-09-07T21:07:39+09:00</updated> <author> <name>minsu-choe</name> <uri>https://powerlichen.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://powerlichen.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://powerlichen.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2024 minsu-choe </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>DRF 페이지네이션 구조 정리</title><link href="https://powerlichen.github.io/posts/django-pagination/" rel="alternate" type="text/html" title="DRF 페이지네이션 구조 정리" /><published>2024-08-18T22:04:00+09:00</published> <updated>2024-08-18T22:04:00+09:00</updated> <id>https://powerlichen.github.io/posts/django-pagination/</id> <content src="https://powerlichen.github.io/posts/django-pagination/" /> <author> <name>minsu-choe</name> </author> <category term="Backend" /> <category term="Django" /> <summary> 개요 DRF에서 ViewSet을 사용하지 않지만, pagination 구조를 사용하기 위해 정리를 진행 해 보았다. ViewSet에서의 기본 사용 예시 DRF에서 페이지네이션은 다음과 같이 사용된다. def list(self, request, *args, **kwargs): queryset = self.filter_queryset(self.get_queryset()) page = self.paginate_queryset(queryset) if page is not None: serializer = self.get_serializer(page, many=True) return self.get_paginated_response(serializer.da... </summary> </entry> <entry><title>인스타그램 API와 저장 최적화</title><link href="https://powerlichen.github.io/posts/django-instagram-api/" rel="alternate" type="text/html" title="인스타그램 API와 저장 최적화" /><published>2024-06-22T21:07:00+09:00</published> <updated>2024-06-22T21:07:00+09:00</updated> <id>https://powerlichen.github.io/posts/django-instagram-api/</id> <content src="https://powerlichen.github.io/posts/django-instagram-api/" /> <author> <name>minsu-choe</name> </author> <category term="Backend" /> <category term="Django" /> <summary> 개요 인스타그램 API를 사용해서 어떤 기능을 만들기로 했다. 인스타그램에서 작성한 게시물들을 받아와 저장해두고, 추후에 서비스에서 게시글을 작성할 때 상단에 미리보기 처럼 나타낼 수 있는 형태이다. 다만 문제가 되는것은 인스타그램 미디어의 이미지, 동영상 부분이었다. 미래에 사용할 거라고 확신할 수 없는 데이터를 저장하는 것은 자원 낭비라고 생각했기에, 갱신 시스템으로 구현을 해 보았다. 인스타그램 게시물 저장 및 갱신 시스템 인스타그램 API를 통해 불러온 미디어는 인스타그램 CDN을 통해 제공되며, 각 미디어는 유효기간을 가진다. 링크의 param에 존재하는 oe라는 필드가 해당 값이다. 이번 구현에서는 인스타그램 API 미디어에서 데이터를 불러올 때 미디어의 유효일자를 항상 계산했다.... </summary> </entry> <entry><title>Django의 쿼리 최적화 - 집합의 활용</title><link href="https://powerlichen.github.io/posts/django-query-optimize-1/" rel="alternate" type="text/html" title="Django의 쿼리 최적화 - 집합의 활용" /><published>2024-02-11T20:45:00+09:00</published> <updated>2024-02-11T20:45:00+09:00</updated> <id>https://powerlichen.github.io/posts/django-query-optimize-1/</id> <content src="https://powerlichen.github.io/posts/django-query-optimize-1/" /> <author> <name>minsu-choe</name> </author> <category term="Backend" /> <category term="Django" /> <summary> 개요 몇달 간 새로운 기능을 작업하고, 기존에 구현되어 있던 코드의 최적화에 시간을 쏟았다. 주어진 여러 문제 중에서, 재미있는 로직을 최적화 한 과정이 있어 소개해보려고 한다. 집합 속성을 통한 contains 처리 문제 프론트엔드에서 하나의 태그를 여러 게시물을 추가하는 작업을 하게 되었다. 프론트 엔드에서 주는 데이터는 다음과 같았다. { ... "posts": [22345, 42345, 23688, 12333, ...] ... } 이전에 태그가 달려있던 post에서는 태그를 삭제하고, 받은 posts에 해당하는 post에만 태그를 추가해야 한다. 기존 코드 post 테이블의 tags 필드는 | 구분자로 구분되어 있었기 때문에, 다음과 같이 구현되어 있었다. ta... </summary> </entry> <entry><title>Django에서 비동기 처리 - 데이터의 처리 구조</title><link href="https://powerlichen.github.io/posts/django-async-2/" rel="alternate" type="text/html" title="Django에서 비동기 처리 - 데이터의 처리 구조" /><published>2023-12-16T10:25:00+09:00</published> <updated>2023-12-16T10:25:00+09:00</updated> <id>https://powerlichen.github.io/posts/django-async-2/</id> <content src="https://powerlichen.github.io/posts/django-async-2/" /> <author> <name>minsu-choe</name> </author> <category term="Backend" /> <category term="Django" /> <summary> 개요 이전 포스트에서는 비동기 처리 시 데이터의 저장 구조에 대해 고민해보았다. 이번에는 저장된 데이터를 어떻게 하면 적절히 처리할 수 있을 지 알아보려고 한다. 최종적으로 결정되었던 데이터 저장 구조는 다음과 같다. 위 구조를 기반으로, 데이터를 처리하는데 어떤 부분을 고려해야할지 생각해보았다. 데이터 처리 구조 처리 사이클 메인 큐에서 N개의 데이터를 가져와 처리를 시작하는 구조를 처리 사이클 이라고 하자. 간략한 구조는 다음과 같다. # 처리 프로세스 qdata_list = 데이터_가져오기_및_키값별_데이터_갯수_최신화() for new_키네임 in qdata_list.keys(): if new_키네임 in 현재_추가된_키네임: continue futu... </summary> </entry> <entry><title>Django에서 비동기 처리 - 데이터의 저장 구조</title><link href="https://powerlichen.github.io/posts/django-async-1/" rel="alternate" type="text/html" title="Django에서 비동기 처리 - 데이터의 저장 구조" /><published>2023-10-12T19:00:00+09:00</published> <updated>2023-10-12T19:00:00+09:00</updated> <id>https://powerlichen.github.io/posts/django-async-1/</id> <content src="https://powerlichen.github.io/posts/django-async-1/" /> <author> <name>minsu-choe</name> </author> <category term="Backend" /> <category term="Django" /> <summary> 개요 서비스에서 하나의 로직을 작성할 때면, 비동기로 작업을 수행해야 할 때가 있다. 일반적으로는 파이썬의 비동기 처리 방법에서 자주쓰이는 Celery가 생각이 들 것이다. 하지만 이번에도 제약조건이 몇가지 있다. 첫번째, celery를 사용할 수 없다. celery worker의 추가 관리 소요에 의해, 당장 사용할 수 없었다. 두번째, 메시지 브로커는 Redis를 사용한다. 메시지 관리에는 RabbitMQ, AWS SQS 같은 좋은 메시지 브로커가 있지만 사용할 수 없었다. 두번째, 외부 서비스의 웹훅을 처리한다. 서비스 내부적으로 동작하는 기능이 아니라, 외부 서비스의 웹훅으로 들어온 데이터를 처리한다. 웹훅 정보 대부분이 최소한의 정보를 가지고 있으므로, 추가 A... </summary> </entry> </feed>
